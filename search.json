[{"title":"记一次公网IPv6配置","date":"2023-02-27T16:00:00.000Z","url":"/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"前言 前段时间突发奇想，想用内网穿透的方式把家里旧电脑上开启的一些服务给暴露在公网上，这样就可以在公司远程访问了。后面查了查资料，发现相比于内网穿透，直接用公网ip去访问更加经济实惠，并且访问速度更快。于是就开始折腾起了公网ip的配置，最后达到的效果如下： 开放任意的端口和服务 通过绑定的域名访问主机 动态修改域名解析配置 需要注意的是，ipv6通信需要过程中的所有网络设备都支持且启用了ipv6网络，目前常见的光猫、路由器都支持ipv6网络，但大多默认没有开启，所以这俩就是我们主要需要配置的地方。这篇文章把折腾的过程记录一下，供其他感兴趣的朋友参考，如有错误也请大家及时指正。 获取公网ip 因为公网ipv4资源紧张，现在三大运营商基本是不会给家庭宽带分配独立的公网ipv4地址了，但所幸除了ipv4，我们还有ipv6，毕竟128位的地址空间，完全不用担心不够用。 ipv6的支持目前已经很普及了，但可能是为了避免不必要的麻烦，光猫的默认设置里面一般是没有开启ipv6选项的。所以我们需要先连上宽带（有线或者无线网络都行），再使用超级管理员账号登录光猫的配置页面去打开这个功能。 默认配置地址为  默认超级管理员账号密码： 移动：CMCCAdmin/aDm8H%MdA 电信：telecomadmin/nE7jA%5m 联通：CUAdmin/CUAdmin 以移动光猫为例，登录后进入网络-宽带设置页面，选择x_INTERNET_xxx连接进行因特网配置 网上查找到的资料大多是使用路由器进行拨号上网，而光猫使用桥接模式，这样配置起来会轻松一些。但由于我这里宽带是房东办的，我不知道密码，所以只能保持光猫拨号，路由器再从光猫这里动态地获取ip地址。所以在这里我只需要打开ipv6地址的自动获取即可，如下图所示： 地址和前缀的获取方式这里可能需要自己尝试下，管不管用取决于运营商开启的分配策略。NPTv6就是ipv6版的NAT协议，如果配置好获取地址和前缀的方式后，电脑直接连接光猫能够获取公网ipv6地址，那么就不需要打开了。 完成宽带设置后，还需要确认下LAN侧地址配置，如下图所示： 保存应用后，将电脑通过网线或者WIFI直接连上光猫，确认是否获取到公网ipv6地址。移动的ipv6是2409开头，电信和联通则是240e和2408，如果没有就需要尝试其他的获取地址方式了。 电脑直连能够获取公网ipv6地址之后，就可以开个服务看看外网能否访问了。我这里直接用python自带的http模块去监听本机8888端口 再使用在线测试工具  判断能否访问（测试时暂时关闭本机和光猫的防火墙） 访问失败，但不知道是哪里出了问题，于是摸索了很久，最后试着打开了光猫的ipv6虚拟服务器功能，填入想要开放公网访问的端口，发现连接成功，估计是光猫的默认策略里禁用了传入的连接，需要在这里单独配置后才能被互联网访问。 这时候我们就可以继续设置路由器了，这里就比较简单了。进入路由器的管理页面，不同品牌和型号的路由器配置方法不同，具体方法可以到生产厂商官网查找对应的配置说明。我这里用的是华硕的RT-AC68U，在高级设置-IPv6中配置ipv6地址获取方式，根据官网的文档，选择穿透模式（Passthrough）即可。 这个模式会把路由器的WAN口、LAN口和WiFi桥接起来，一级路由（即光猫）下发的ipv6地址通过网桥直接分配给二级路由下的终端，可以理解为在ipv6网络中，我的路由器是以交换机模式工作的。 配置完后，同样暂时关闭路由器的ipv6防火墙，电脑连接路由器的WiFi，看是否能够像直连光猫一样获取公网ipv6，获取到了基本就没问题了。 防火墙配置 毕竟是直接暴露在公网上，访问控制还是得做的。主要是光猫、路由器、电脑本机上的防火墙策略需要开启。 光猫的配置页面里面，在安全-防火墙中配置防火墙策略，但这里只能选择低中高等级，并不知道具体控制策略，主要起一个心理作用。 路由器的配置，在高级设置-防火墙里面可以配置，开启ipv6防火墙后默认拒绝所有传入连接，可指定ip和端口开放，但考虑到主机ip是从光猫动态获取的，可能会变化，所以这里就没有启用。 终端防火墙的配置，Windows可以直接在高级防火墙设置里添加允许的传入连接，未匹配到允许规则时windows防火墙默认会拒绝连接。 域名配置 能通过IP访问后，为了让访问过程更方便，我决定申请个域名，通过域名来访问主机，再通过定时执行检查脚本来实现ddns的功能。 查了一些资料后，我在namesilo花 1.88 美元租了个一年的域名，选他主要是因为便宜、免备案还免费提供whois信息隐藏服务，再把域名解析服务器设置为阿里云，这样管理起来方便一点。 这里配置完后，到阿里云的控制台，找到云解析DNS，页面上简单配置即可，这样下来我们就可以愉快地通过域名访问家里的主机了。 最后是定时检查ip是否改变，这里我参照阿里云的openApi简单写个python脚本，发现ip变化就通过阿里云的Api去修改解析记录，再通过计划任务运行即可。 注意事项 尽管我们通过防火墙对传入连接做了限制，但尽量还是只开放一些静态内容，比如个人博客。如果一定要开放一些FTP、SSH之类的服务，记得选择没有公开漏洞的组件版本，并使用强口令认证。 TODO 使用虚拟机对外开放服务 证书配置 "},{"title":"git笔记","date":"2021-07-25T16:00:00.000Z","url":"/2021/07/26/%E5%A4%87%E5%BF%98/git%E7%AC%94%E8%AE%B0/","tags":[["git","/tags/git/"]],"categories":[["备忘","/categories/%E5%A4%87%E5%BF%98/"]],"content":"概览 与svn等集中式版本控制系统不同，git为分布式版本控制系统，每个开发者都保存整个项目的完整镜像 工作区间: 即我们创建的工程文件， 在编辑器可直观显示； 暂存区: 只能通过git GUI或git shell 窗口显示，提交代码、解决冲突的中转站； 本地仓库: 只能在git shell 窗口显示，连接本地代码跟远程代码的枢纽，不能联网时本地代码可先提交至该处； 远程仓库: 即保存我们代码的服务器，本文以公共版本控制系统：github为例，登录github账号后可直观显示； Git特点 直接记录快照，而非比较差异 Git只关心文件数据的整体是否发生变化，而不是文件内容的具体差异。当文件整体发生变化时（比较指纹信息），则记录快照；若文件整体不变，则只保存上一版本快照的索引，避免重复存储。 几乎所有操作都是本地执行 Git中绝大多数操作都只需要访问本地文件和资源，不用联网。 校验和（checksum）为文件的唯一标识 一旦文件的完整性收到损坏，那么git就能立刻察觉到。 多数操作仅添加数据 常用的Git操作大多仅仅是把数据添加到数据库，因为任何一种不可逆的操作（如删除）都会使回退变得更加困难。 文件的三种状态 对于任何一个文件，在Git中只有已提交（committed），已修改（modified）和已暂存（staged）三种状态。 已提交表示该文件已经被安全地保存在本地数据库； 已修改表示修改了某个文件，但还没有提交保存； 已暂存表示把已修改的文件放在下次提交时要保存的清单中了 使用方法 获得一个Git仓库 git初始化 要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行： 初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： git clone git clone用于从服务器上获取git仓库，并且获取的是项目历史的所有数据（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态。 如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字： 状态检查 查看当前项目的git状态 对比文件修改情况 git diff命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容 若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff --cached（Git 1.6.1 及更高版本还允许使用git diff --staged，效果是相同的，但更好记些。） 查看提交历史 理解head和master 基础配置 查看git配置信息 配置远程地址 记住密码 .gitignore 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以在项目根目录下创建如下一个名为 .gitignore 的文件，列出要忽略的文件模式 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号＃开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 * 匹配模式最后跟反斜杠/说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号!取反 工作区&lt;-&gt;暂存区 add git add是一个多功能命令，它可以将项目文件纳入跟踪范围，也可以将所做的修改暂存到暂存区，git commit只会把已加入暂存区的文件版本提交到本地仓库，所以每对项目文件做一次修改，都要使用git add命令将它加入暂存区，否则提交的可能就是修改之前的版本了。 文件操作 git rm git rm &lt;filename&gt;用来将不需要的文件同时从Git仓库和工作目录中删除，如果只是手动从工作目录中删除该文件，则还会在&quot;Changed but not updated&quot;中看到。 如果希望在工作目录中保留文件，只从git仓库中删除，那么可以加上--cached参数 git mv 常用于文件移动和重命名 回滚 贮藏更改 场景一：当你在工作区做了一些修改，并想要将这些修改提交到git仓库时，你发现共同开发这个项目的同事已经提交了一些内容。这时候你如果直接提交并推送到远程仓库，就会因为分支冲突而推送失败。 场景二：当你在分支dev做了一些修改之后，想切换到master分支去做一些事情，但又不想为做到一半的工作创建一次提交，那么你就需要将你所做的修改贮藏起来。 为了解决这些问题，我们可以使用git stash命令，将我们的在工作区所做的更改贮藏到一个栈上，并且在任何时候重新应用这些改动（甚至在不同的分支上） 常用的git stash命令用法如下所示： 更详细的说明可以参考：工具-贮藏与清理 暂存区&lt;-&gt;本地仓库 git commit 一般使用git comit -m &quot;your comment&quot;将代码提交到本地仓库，提交后工作区清空，再次修改则需要重新git add，如果不加-m参数，那么会启动文本编辑器以输入本次提交的说明。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，加上-a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 本地仓库&lt;-&gt;远程仓库 git push 将本地的分支版本上传到远程并合并 git fetch 从远程仓库下载最新的commit，并且同时保留本地分支head和远程分支remotes，需要另外使用git merge合并分支 git pull 下载远程分支中最新的commit并合并（不建议使用，可能出现未解决代码冲突的情况） 操作撤销 在进行文件修改等操作后，使用git status查看状态，可以看到git给出的撤销提示 更多参考：git checkout，git restore 和 git reset reset版本回退 首先git log查看历史提交的版本信息，得到各个commit的id，即其哈希值 然后使用git reset --hard &lt;commitId&gt;切换到各个版本提交时的状态（清空暂存区），如果版本已提交到远程仓库，则需要在本地仓库回退后使用git push -f将操作强制同步到远程仓库。 但实际上回退之前的版本还是存在的，使用git reflog可以查看历史版本记录，找到已提交过的任何一个版本的commitId，通过commitId仍可以切回最新的未回退的版本。 revert版本回退 使用git reset回退公共远程分支的版本后，其他人都需要用远程master分支覆盖本地master分支，显然，这不是优雅的回退方法，而revert命令则可以避免这个问题。 git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的。所以，当你用revert回退完，所有人pull之后，代码也自动回退了。 分支管理 分支新建、切换、删除 在一个分支进行文件修改、新建、删除等操作在commit后不会影响其他分支。 分支合并 在将branch2合并到branch1的过程中，branch2中新建文件、删除原有文件、修改原有文件等操作将同步到branch1，当两个分支都做出修改时，可能会出现代码冲突，这时候需要我们手动修改解决冲突后再次提交才能合并成功。 如果我们的主分支 master ，在 checkout 一个新的分支（bugfix）后，产生了多次提交，这时候我们将bugfix分支合并到master，bugfix分支上新产生的所有提交记录都会同步到master，导致主线版本的提交记录杂乱。如果我们想要在合并分支时只产生一条提交记录，则需要使用--squash参数， 常见问题 新建GitHub仓库，第一次push时验证账号密码失败 一开始提示输入GitHub的用户名口令，正确输入后还是验证失败。这时候会出现新的登录窗口，提示通过OpenSSH登录到GitHub，这时候，输入GitHub用户名和access token（settings-developer settings-Personal access tokens）即可登录成功 配置免密登录  "},{"title":"网络代理设置","date":"2021-07-07T16:00:00.000Z","url":"/2021/07/08/%E5%A4%87%E5%BF%98/%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["备忘","/categories/%E5%A4%87%E5%BF%98/"]],"content":"命令行代理设置 设置命令行代理（设置环境变量,命令行关闭后则失效） git代理设置 设置永久有效 go代理设置 Bash (Linux / macOS) PowerShell (Windows) "},{"title":"TCP&IP","date":"2021-03-13T16:00:00.000Z","url":"/2021/03/14/%E5%A4%87%E5%BF%98/TCP&IP/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["备忘","/categories/%E5%A4%87%E5%BF%98/"]],"content":"TCP 三次握手和四次挥手 TCP是可靠的，面向连接的传输层协议，端到端之间要进行TCP通信首先就要建立起TCP连接，当通信结束时断开TCP连接。这里TCP连接的建立与断开过程就分别由三次握手和四次挥手来完成。 三次握手 TCP连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。具体过程如下图所示。 第一次握手： 建立连接。客户端发送连接请求报文段，SYN位置为1，Sequence Number为随机数i；然后，客户端进入SYN_SENT状态，等待服务器的确认； 第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为i+1 ( Sequence Number+1 )；同时，自己自己还要发送SYN请求信息，SYN设置为1，Sequence Number为j；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RCVD状态； 第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为j+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 在wireshark中可以分别查看ACK和Seq的实际值和相对值，第一个包的Seq相对值为0。 Seq的相对值为当前端已发送的TCP总段长，ACK的相对值为当前端已接收的TCP总段长（单位：字节），SYN标志位和FIN标志位也要占1字节（其他标志位如ACK不占）。 四次挥手 中断连接端可以是Client端，也可以是Server端。 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，“就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ TCP和UDP的对比 有连接/无连接（可靠/不可靠） 有拆分合并/无拆分合并 有拥塞控制/无拥塞控制（发送速率的调整） 单播/多播 滑动窗口和流量控制 拥塞控制 http/https http各版本区别 http1.0 vs http1.1 http1.1开始，默认使用长连接（HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。） http1.1增加了一些错误状态码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 SSL/TLS 首先由客户端发送Client Hello 消息到服务器，消息中主要包含了客户端支持的ciphersuites， TLS 版本信息和客户端随机数。注意此时是明文传输 服务器接收到消息后，返回自己支持的ciphersuites， TLS 版本，自己的数字证书和服务器端生成的随机数。注意此时是明文传输 客户端开始验证数字证书，可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，直到一个受信的 CA。验证完证书之后生成一个新的pre-master key，再使用证书中的公钥来对pre-master key进行加密，然后发送给服务器。注意此时是非对称加密传输 服务器接收到客户端发送过来的非对称加密的密文，使用自己的私钥进行解密，获得了pre-master key。注意此时是非对称加密传输 到这里为止，服务器和客户端都有三组数字，**分别是客户端的随机数、服务器的随机数和pre-master key。**其中由于客户端的随机数和服务器的随机数都是使用明文传输，所以这两个数字是有被暴露的风险的，但是由于pre-master key是使用非对称加密传输，十分安全，所以将这三者结合，使用之前协商好的特定的算法就可以生成一个密钥，这个密钥称为shared secert。也就是之后用来对称加密的密钥。 客户端在计算出对称加密的密钥之后，使用该密钥进行对称加密通信，告知服务器之后都使用该密钥进行对称加密。注意此时是对称加密传输 服务器接收到密文后，使用之前计算出的密钥来进行对称解密，解密成功之后，再使用该密钥进行对称加密通信。告知客户端密钥确认无误，可以使用该密钥进行通信。注意此时是对称加密传输 至此，整个TLS的握手过程完整，之后就可以开始对称加密的通信了。 参考文章 TCP协议中的三次握手和四次挥手(图解) 关于 TCP/IP，必知必会的10个问题 "},{"title":"如何做好应急响应","date":"2021-03-07T16:00:00.000Z","url":"/2021/03/08/%E6%94%BB%E9%98%B2/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/","tags":[["应急响应","/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"]],"categories":[["攻防","/categories/%E6%94%BB%E9%98%B2/"]],"content":"整体思路 1）准备 准备检测工具、确定相关人员。 2）检测与分析 入侵事件研判，检索分析态势感知等安全设备产生入侵告警和相关日志，确定攻击者及威胁影响范围。 3）抑制缓解 封堵攻击源、控制威胁影响范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境。 4）攻击溯源 综合分析安全设备告警、日志，主机系统日志、开放服务日志，确定攻击者入侵路径，及时修补存在的漏洞。 5）业务恢复 入侵检查 Linux 常用命令 命令 作用 last 显示的是目前与过去登入系统的用户相关信息 lastlog 显示所有用户的登录情况 lastb 显示用户错误的登录列表 who 显示的是当前登录的用户 w 比who显示多一些内容，比如用户当前执行的命令，cpu信息 history 查看历史命令记录 检查步骤 检查账号及登录情况 见这篇文章：Linux系统加固 检查历史命令 检查网络连接/开放端口 检查异常进程 检查开机启动项 检查定时任务 检查服务 检查异常文件 查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“…”为名的文件夹具有隐藏属性 针对可疑文件可以使用stat查看创建修改时间 发现WebShell、远控木马的创建时间 找出同一时间范围内创建的文件？ 检查日志文件 日志默认存放位置：/var/log/ 查看日志配置情况：more /etc/rsyslog.conf 日志文件 说明 /var/log/cron 记录系统定时任务相关的日志 /var/log/message 记录Linux操作系统常见的系统和服务错误信息(首要检查对象) /var/log/syslog 只记录警告信息，常常是系统出问题的信息 /var/log/btmp 记录错误登录（登陆失败）日志；使用lastb命令查看 /var/log/lastlog 记录系统中所有用户最后一次成功登录时间，使用lastlog命令查看 /var/log/wtmp 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件；用last命令来查看 /var/log/utmp 只记录当前登录用户的信息；使用w,who,users等命令来查询 /var/log/secure 记录验证和授权方面的信息，如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码 /var/log/apache2/error.log apache错误日志，如果安装有modsecurity那么其攻击拦截日志也存在这里 "},{"title":"Linux系统加固","date":"2021-03-06T16:00:00.000Z","url":"/2021/03/07/%E6%94%BB%E9%98%B2/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/","tags":[["系统加固","/tags/%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/"]],"categories":[["攻防","/categories/%E6%94%BB%E9%98%B2/"]],"content":"账号安全 账号相关文件 修改密码策略 vim /etc/login.defs 设置密码强度 vim /etc/pam.d/common-password 将原本的 修改为至少包含一个数字、一个小写字母、一个大写字母、一个特殊字符、且密码长度&gt;=8: 限制用户登陆 vim /etc/hosts.deny，若禁止192.168.0.1对服务器进行ssh的登陆，添加如下内容 限制登陆次数 应对暴力破解，我们可以限制登陆次数为5，超过5次登陆失败就锁定**。**vim /etc/pam.d/sshd，在 #%PAM-1.0 的下面，加入下面的内容，表示当密码输入错误达到3次，就锁定用户150秒，如果root用户输入密码错误达到3次，锁定300秒。 锁定用户的管理： 目录&amp;文件权限 存储用户信息的文件 在用户登陆中非常重要的三个文件 /etc/passwd 必须所有用户都可读，root用户可写 –rw-r—r— 权限值为644 /etc/shadow 只有root可读 –r-------- 权限值为400 /etc/group 必须所有用户都可读，root用户可写 –rw-r—r— 权限值为644 文件缺省权限设置 应用安全设置 FTP 禁止匿名FTP vim /etc/vsftpd/vsftpd.conf SSH 在sshd_config禁止root访问和使用sshv2来让ssh更加安全 vim /etc/ssh/sshd_config 设置SSH空闲超时退出时间,可降低未授权用户访问其他用户ssh会话的风险 编辑/etc/ssh/sshd_config，将ClientAliveInterval 设置为300到900，即5-15分钟，将ClientAliveCountMax设置为0-3之间。 设置较低的Max AuthTrimes参数将降低SSH服务器被暴力攻击成功的风险 在/etc/ssh/sshd_config中取消MaxAuthTries注释符号#，设置最大密码尝试失败次数3-6，建议为4： TELNET Telnet使用明文传输数据，存在安全隐患，应该避免使用 执行如下语句，查看telnet服务是否在运行 若正在运行则关闭Telnet服务，在/etc/xinetd.d/telnet中进行配置 网络设置 IPTABLES 根据需求合理配置防火墙 比如将INPUT链默认规则设为DROP，再添加规则将需要开放的端口设置为ACCEPT TCP SYN保护机制 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击"},{"title":"2020信安国赛WriteUp","date":"2020-08-21T16:00:00.000Z","url":"/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/","tags":[["CTF","/tags/CTF/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"Misc the_best_ctf_game 解压得到二进制文件:flag 使用winhex打开 观察到 即flag的值 电脑被黑 解压缩包得到disk_dump文件 使用file 命令查看信息 可以看到是ext3的文件系统 挂载到 test文件夹下 查看???.png，提示flag已被删除 使用extundelete恢复被删除的文件 得到flag.txt，但打开后是乱码 返回test/misc01文件夹下，看到可执行文件demo 使用strings命令查看 猜测demo对flag.txt进行了处理 使用ida反编译查看其伪源码 编写代码对flag文件进行解码 解码后得到flag Crypto 只做出来一道题 baby 一道RSA的密码学题目 给了我们密文c和因数n，e很小。所以可以通过爆破的方式跑出明文 解密脚本 结果是 再解码得到flag "},{"title":"MySQL的自动类型转换","date":"2020-07-21T16:00:00.000Z","url":"/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"在查询语句的条件判断子句中，如果等号左右两边的类型不同，则会自动进行类型转换。以如下数据表为例 DVWA的user表👆 在进行以下查询时结果如图： 通过上面几个查询的例子可以看到，mysql查询语句的条件判断中，像user_id = ‘xxx’ 这种条件，user_id 是整型，而 ‘xxx’ 是字符串型，在判断时，'xxx’会被当作一个整型与 user_id进行比较。 而转换的规则也很有意思。 ‘1 and 1=1’ 被当作 1 ‘1 and 1=2’ 也被当作1 ‘2 and 1=1’ 被当作2 经过更多的测试可以发现 这个字符串（不论是单引号或者是双引号）在被当作整型数进行处理的时候 如果第一个字符不是数字，那么该字符串被当成0来处理； 如果第一个字符是数字，那么这个字符串就等于从第一个字符开始的数字串 比如：‘4gsb’ = 4；‘108hh’ = 108"},{"title":"docker常用命令","date":"2020-07-19T16:00:00.000Z","url":"/2020/07/20/%E5%A4%87%E5%BF%98/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["docker","/tags/docker/"]],"categories":[["备忘","/categories/%E5%A4%87%E5%BF%98/"]],"content":"镜像管理 配置镜像仓库的国内加速地址 从云端镜像仓库获取新镜像 容器管理 从镜像创建并运行一个新容器 管理已创建的容器 Docker Compose 使用 Docker Compose 可以很方便地定义和运行多容器应用程序，通过yml文件即可进行配置。 "},{"title":"正则表达式笔记","date":"2020-04-18T08:35:13.000Z","url":"/2020/04/18/%E5%A4%87%E5%BF%98/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/","tags":[["正则表达式","/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"]],"categories":[["备忘","/categories/%E5%A4%87%E5%BF%98/"]],"content":"简介 正则表达式是描述一组字符串特征的模式，用来匹配特定的字符串。 ——Ken Thompson 一个正则表达式是一串特殊的字符串，它可以用于匹配一组字符串。比如 就是一个简单的正则表达式，它可以用来匹配0~9范围内的任意一个数字。 而上面这个式子也是一个正则表达式，只不过复杂了一些，它可以匹配10位的北美电话号码。无论区号是否加括号，数字间是否有句点或连字符，它都可以匹配。 学习时用到的工具： Regexpal网站：可以在线测试正则表达式 基础 字符的匹配 字面值匹配 最简单的一种，比如一个数字字符串666，可以在目标文本中匹配所有的666 字符组匹配 正则表达式将方括号[]视为特殊的元字符，因此方括号本身不参与匹配，而对括号内容进行匹配。字符组包括以下几种情况： [aBc]：匹配a,B,c三个字符中的其中一个 [0-9]：匹配0到9范围内的任意数字。要匹配任意3位数字可以用 [0-9][0-9][0-9] [a-z]：匹配所有小写字母 [A-Z]：匹配所有大写字母 [a-zA-Z]：匹配所有大小写字母 [^ARP]：匹配除了A,R,P以外的所有字符 [^a-z]：匹配所有除了小写字母以外的字符 字符组简写式（元字符） 例如：[0-9]可以简写为\\d，它们都能匹配0到9之间的任意一个数字。 空白字符： \\f：换页符 \\n：换行符 \\r：回车符 \\t：制表符（Tab的缩进） \\v：垂直制表符 \\s：任意一个空白字符，等价于 [\\f\\n\\r\\t\\v] \\S：对\\s取非，即任意非空字符 数字元字符： \\d：匹配任意阿拉伯数字 \\D：匹配任意非数字字符（如连字符-) 字母数字元字符： \\w：大小写字母，下划线和数字，等价于[a-zA-Z0-9] \\W：对\\w取非 任意字符的匹配 .：点号（英文句号）可以匹配任意字符（但一般不匹配换行符）。 .是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \\ 进行转义，即在 . 前面加上 \\ 。 捕获分组和后向引用 将\\d放到()中，则\\d匹配到一个数字的同时该数字被捕获。捕获之后则可以被后向引用。 \\1后向引用被捕获的字符。 例如：正则表达式 (\\d)\\d\\1 可以匹配 101 或者 212 , 383 等等,但无法匹配 102 。因为\\1引用的是那个被捕获的字符，所以这个正则表达式匹配到的一定是某三个相连数字，其中第一个数字和第三个数字一定是相同的。 量词 \\d&#123;3&#125;匹配三个相连数字，这里&#123;3&#125;就是一个量词，花括号中可以有多个数字（用逗号,隔开）比如&#123;3,4&#125;表示3个或者4个； \\d-?匹配一个数字，如果该数字之后跟着一个连字符那么连字符也会被匹配到。这里的?也是一个量词，表示0个或1个； 同理，其他常用的量词还有 +：表示1个或者多个 *：表示0个或者多个 括选文字符 现在可以看看下面这个比较健壮的表达式了，就是简介中的那个，它匹配10位的北美电话号码 ^匹配行起始位置，即^后面跟着的内容(\\(\\d&#123;3&#125;\\)|^\\d&#123;3&#125;[.-]?)必须出现在行首； \\(和\\)就是将左右括号转义，让它表示其字面意思，而不是捕获分组的开始结束标志； |表示或运算，即匹配|两边的内容之一； [.-]匹配一个可选的点号（这里点号不再匹配任意字符）或连字符； $匹配行的结束标志 这个表达式最终匹配十位的北美电话号码，而且括号、连字符或者点号都是可选的。你可以试试不同格式的电话号码，看看它能否匹配。以上正则表达式中的捕获分组并不是必需的。分组是必要的，但是捕获不需要。更好的方法是使用非捕获分组。 模式匹配 留坑待填"},{"title":"在Markdown中使用emoji表情","date":"2020-04-07T13:25:36.000Z","url":"/2020/04/07/%E6%9D%82%E8%AE%B0/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/","tags":[["Markdown","/tags/Markdown/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"常用emoji 理想情况下，在Markdown编辑器中输入如上图所示的语句后将显示对应的emoji表情。但实际上是否显示则取决于你的markdown解析器。 hexo博客使用emoji hexo 框架默认的markdown解析器是hexo-renderer-marked，并不支持emoji表情的解析。所以如果想要在博客文章里添加emoji表情😮，可以考虑使用hexo-renderer-markdown-it 解析器。 首先打开Node.js的命令行并移动到你的博客根目录下 卸载原有的hexo-renderer-marked： 再安装hexo-renderer-markdown-it ： 完成之后安装所需的插件： 最后打开根目录下的_config.yml文件，添加以下配置： 然后保存退出，再重新加载一下hexo即可。 参考来源： ZucchinY的博客"},{"title":"关于我","date":"2020-04-05T16:00:00.000Z","url":"/2020/04/06/%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%88%91/","tags":[["关于我","/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"一个对网络安全初窥门径的人，偶尔会心血来潮想要写写代码。 邮箱：dawnyh@qq.com，欢迎交流 ~"},{"title":"friends","date":"2024-05-01T14:19:24.064Z","url":"/friends/index.html","categories":[[" ",""]]},{"title":"categories","date":"2023-01-14T10:25:20.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"tags","date":"2023-01-14T10:24:54.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"search","date":"2023-01-14T10:20:31.000Z","url":"/search/index.html","categories":[[" ",""]]}]