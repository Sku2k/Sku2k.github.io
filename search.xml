<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker常用命令</title>
    <url>/2020/07/20/%E5%A4%87%E5%BF%98/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="镜像管理"><a class="header-anchor" href="#镜像管理"></a>镜像管理</h2>
<h3 id="配置镜像仓库的国内加速地址"><a class="header-anchor" href="#配置镜像仓库的国内加速地址"></a>配置镜像仓库的国内加速地址</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Ubuntu16.04+、Debian8+、CentOS7适用</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 创建或修改daemon配置文件:/etc/docker/daemon.json,内容如下</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://&lt;个人ID&gt;.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 保存文件后，重启服务</span></span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="从云端镜像仓库获取新镜像"><a class="header-anchor" href="#从云端镜像仓库获取新镜像"></a>从云端镜像仓库获取新镜像</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装最新版镜像</span></span></span><br><span class="line">docker pull &lt;镜像名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定镜像版本安装</span></span></span><br><span class="line">docker pull &lt;镜像名&gt;:&lt;镜像版本&gt;</span><br></pre></td></tr></table></figure>
<h2 id="容器管理"><a class="header-anchor" href="#容器管理"></a>容器管理</h2>
<h3 id="从镜像创建并运行一个新容器"><a class="header-anchor" href="#从镜像创建并运行一个新容器"></a>从镜像创建并运行一个新容器</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 前台运行</span></span></span><br><span class="line">docker run &lt;镜像名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 后台运行</span></span></span><br><span class="line">docker run -d &lt;镜像名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 把容器的一个服务端口映射到宿主机上</span></span></span><br><span class="line">docker run -p &lt;宿主机端口&gt;:&lt;容器端口&gt; &lt;镜像名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 映射多个端口</span></span></span><br><span class="line">docker run -p &lt;宿主机端口1&gt;:&lt;容器端口1&gt; \</span><br><span class="line">			-p &lt;宿主机端口2&gt;:&lt;容器端口2&gt; \</span><br><span class="line">			-p &lt;宿主机端口3&gt;:&lt;容器端口3&gt; &lt;镜像名&gt;</span><br><span class="line">			</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 指定容器名</span></span></span><br><span class="line">docker run --name &lt;容器名&gt; &lt;镜像名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 以交互模式运行,在容器内执行 /bin/bash 命令</span></span></span><br><span class="line">docker run -it &lt;镜像名&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="管理已创建的容器"><a class="header-anchor" href="#管理已创建的容器"></a>管理已创建的容器</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 列出运行中的容器,以下二者都可以</span></span></span><br><span class="line">docker container ls</span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 列出所有已创建的容器，包括停止运行的</span></span></span><br><span class="line">docker container ls -a</span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动 | 停止 | 重启 | 删除容器</span></span></span><br><span class="line">docker [ start | stop | restart | rm ] &lt;容器名或容器ID&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重命名容器</span></span></span><br><span class="line">docker rename &lt;原容器名&gt; &lt;新容器名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 交互模式在容器内执行 /bin/bash 命令</span></span></span><br><span class="line">docker run -it &lt;容器名或容器ID&gt; /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 从宿主机拷贝文件或文件夹到容器</span></span></span><br><span class="line">docker cp &lt;宿主机中的文件路径&gt; &lt;容器名或容器ID&gt;:&lt;容器内文件路径&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 从容器拷贝文件或文件夹到宿主机</span></span></span><br><span class="line">docker cp &lt;容器名或容器ID&gt;:&lt;容器内文件路径&gt; &lt;宿主机中的文件路径&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Docker-Compose"><a class="header-anchor" href="#Docker-Compose"></a>Docker Compose</h2>
<p>使用 Docker Compose 可以很方便地定义和运行多容器应用程序，通过yml文件即可进行配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 首先移动到docker-compose.yml配置文件所在目录</span></span></span><br><span class="line">cd &lt;docker-compose.yml所在目录&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 前台运行应用程序</span></span></span><br><span class="line">docker-compose up</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 后台运行应用程序</span></span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 停止应用程序</span></span></span><br><span class="line">docker-compose stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重新启动应用程序</span></span></span><br><span class="line">docker-compose restart</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 删除停止运行的容器</span></span></span><br><span class="line">docker-compose rm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 停止运行应用程序并删除对应容器</span></span></span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2021/07/26/%E5%A4%87%E5%BF%98/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概览"><a class="header-anchor" href="#概览"></a>概览</h2>
<p>与svn等集中式版本控制系统不同，git为分布式版本控制系统，每个开发者都保存整个项目的完整镜像</p>
<p><img src="/2021/07/26/%E5%A4%87%E5%BF%98/git%E7%AC%94%E8%AE%B0/211915189723300.jpg" class="lazy" data-srcset="/2021/07/26/%E5%A4%87%E5%BF%98/git%E7%AC%94%E8%AE%B0/211915189723300.jpg" srcset="/images/loadingImage.gif" alt="211915189723300.jpg"></p>
<p>工作区间: 即我们创建的工程文件， 在编辑器可直观显示；</p>
<p>暂存区: 只能通过git GUI或git shell 窗口显示，提交代码、解决冲突的中转站；</p>
<p>本地仓库: 只能在git shell 窗口显示，连接本地代码跟远程代码的枢纽，不能联网时本地代码可先提交至该处；</p>
<p>远程仓库: 即保存我们代码的服务器，本文以公共版本控制系统：github为例，登录github账号后可直观显示；</p>
<h2 id="Git特点"><a class="header-anchor" href="#Git特点"></a>Git特点</h2>
<p><strong>直接记录快照，而非比较差异</strong></p>
<p>Git只关心文件数据的整体是否发生变化，而不是文件内容的具体差异。当文件整体发生变化时（比较指纹信息），则记录快照；若文件整体不变，则只保存上一版本快照的索引，避免重复存储。</p>
<p><strong>几乎所有操作都是本地执行</strong></p>
<p>Git中绝大多数操作都只需要访问本地文件和资源，不用联网。</p>
<p><strong>校验和（checksum）为文件的唯一标识</strong></p>
<p>一旦文件的完整性收到损坏，那么git就能立刻察觉到。</p>
<p><strong>多数操作仅添加数据</strong></p>
<p>常用的Git操作大多仅仅是把数据添加到数据库，因为任何一种不可逆的操作（如删除）都会使回退变得更加困难。</p>
<p><strong>文件的三种状态</strong></p>
<p>对于任何一个文件，在Git中只有已提交（committed），已修改（modified）和已暂存（staged）三种状态。</p>
<p>已提交表示该文件已经被安全地保存在本地数据库；</p>
<p>已修改表示修改了某个文件，但还没有提交保存；</p>
<p>已暂存表示把已修改的文件放在下次提交时要保存的清单中了</p>
<h2 id="使用方法"><a class="header-anchor" href="#使用方法"></a>使用方法</h2>
<h3 id="获得一个Git仓库"><a class="header-anchor" href="#获得一个Git仓库"></a>获得一个Git仓库</h3>
<p><strong>git初始化</strong></p>
<p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add *.c		#把所有的c源码纳入版本控制（加入暂存区）</span><br><span class="line">git add README	#把README加入版本控制（加入暂存区）</span><br><span class="line">git commit -m &#x27;initial project version&#x27;		#提交代码到本地仓库</span><br></pre></td></tr></table></figure>
<p><strong>git clone</strong></p>
<p><code>git clone</code>用于从服务器上获取git仓库，并且获取的是项目历史的所有数据（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>
<p>如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure>
<h3 id="状态检查"><a class="header-anchor" href="#状态检查"></a>状态检查</h3>
<p><strong>查看当前项目的git状态</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status	## 在项目根目录下运行</span><br></pre></td></tr></table></figure>
<p><strong>对比文件修改情况</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff</span><br><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>
<p><code>git diff</code>命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容</p>
<p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code>（Git 1.6.1 及更高版本还允许使用<code>git diff --staged</code>，效果是相同的，但更好记些。）</p>
<p><strong>查看提交历史</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log [-p] [-2]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># -p 表示展开显示每次提交的内容差异，-2 表示仅展示最近的两次提交</span></span></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/bdss58/article/details/40537859">理解head和master</a></p>
<h3 id="基础配置"><a class="header-anchor" href="#基础配置"></a>基础配置</h3>
<p><strong>查看git配置信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -l ## 显示所有当前配置</span><br><span class="line">git config --global -l  ## 显示所有全局配置</span><br><span class="line">git config --local -l  ## 显示所有当前仓库独有配置</span><br><span class="line">git config --unset user.name ## 删除 user.name 配置项</span><br></pre></td></tr></table></figure>
<p><strong>配置远程地址</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add &lt;name&gt; &lt;url&gt;  ## 添加远程地址，可添加多个</span><br><span class="line">git remote remove &lt;name&gt; ## 删除远程地址</span><br></pre></td></tr></table></figure>
<p><strong>记住密码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config credential.helper store ## 设置记住密码</span><br><span class="line">git config credential.helper &#x27;cache --timeout 0&#x27; ## 15min后清除密码</span><br></pre></td></tr></table></figure>
<p><strong>.gitignore</strong></p>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以在项目根目录下创建如下一个名为 .gitignore 的文件，列出要忽略的文件模式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">## 此为注释 – 将被 Git 忽略</span><br><span class="line">*.a       ## 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    ## 但 lib.a 除外</span><br><span class="line">/TODO     ## 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/    ## 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt ## 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">*.[oa]    ## 忽略所有以 .o 或 .a 结尾的文件（编译过程文件）</span><br><span class="line">*~        ## 忽略所有以波浪符 ~ 结尾的文件（文件副本）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文件 .gitignore 的格式规范如下：<br>
所有空行或者以注释符号<code>＃</code>开头的行都会被 Git 忽略。<br>
可以使用标准的 glob 模式匹配。<code> *</code> 匹配模式最后跟反斜杠<code>/</code>说明要忽略的是目录。<br>
要忽略指定模式以外的文件或目录，可以在模式前加上叹号<code>!</code>取反</p>
</blockquote>
<h3 id="工作区-暂存区"><a class="header-anchor" href="#工作区-暂存区"></a>工作区&lt;-&gt;暂存区</h3>
<h4 id="add"><a class="header-anchor" href="#add"></a>add</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add [options] [&lt;file&gt;…]</span><br></pre></td></tr></table></figure>
<p><code>git add</code>是一个多功能命令，它可以将项目文件纳入跟踪范围，也可以将所做的修改暂存到暂存区，<code>git commit</code>只会把已加入暂存区的文件版本提交到本地仓库，所以每对项目文件做一次修改，都要使用<code>git add</code>命令将它加入暂存区，否则提交的可能就是修改之前的版本了。</p>
<h4 id="文件操作"><a class="header-anchor" href="#文件操作"></a>文件操作</h4>
<p><strong>git rm</strong></p>
<p><code>git rm &lt;filename&gt;</code>用来将不需要的文件同时从Git仓库和工作目录中删除，如果只是手动从工作目录中删除该文件，则还会在&quot;Changed but not updated&quot;中看到。</p>
<p>如果希望在工作目录中保留文件，只从git仓库中删除，那么可以加上<code>--cached</code>参数</p>
<p><strong>git mv</strong></p>
<p>常用于文件移动和重命名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mv file_from file_to</span><br></pre></td></tr></table></figure>
<h4 id="回滚"><a class="header-anchor" href="#回滚"></a>回滚</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git restore &lt;file&gt;    # 丢弃工作区的修改（包括对文件自身的操作，如添加文件、删除文件）</span><br><span class="line">git restore --staged &lt;file&gt;    #将暂存区的修改重新放回工作区（包括对文件自身的操作，如添加文件、删除文件）</span><br></pre></td></tr></table></figure>
<h4 id="贮藏更改"><a class="header-anchor" href="#贮藏更改"></a>贮藏更改</h4>
<p>场景一：当你在工作区做了一些修改，并想要将这些修改提交到git仓库时，你发现共同开发这个项目的同事已经提交了一些内容。这时候你如果直接提交并推送到远程仓库，就会因为分支冲突而推送失败。</p>
<p>场景二：当你在分支<code>dev</code>做了一些修改之后，想切换到<code>master</code>分支去做一些事情，但又不想为做到一半的工作创建一次提交，那么你就需要将你所做的修改贮藏起来。</p>
<p>为了解决这些问题，我们可以使用<code>git stash</code>命令，将我们的在工作区所做的更改贮藏到一个栈上，并且在任何时候重新应用这些改动（甚至在不同的分支上）</p>
<p>常用的<code>git stash</code>命令用法如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash save &quot;some messages&quot; # 贮藏工作区的修改，将工作区变成上次提交时的样子</span><br><span class="line">git stash list  # 列出已经贮藏的内容</span><br><span class="line">git stash apply  # 将最近一次的贮藏应用到当前分支</span><br><span class="line">git stash apply stash@&#123;2&#125;  # 将 stash@&#123;2&#125; 这个贮藏应用到当前分支</span><br><span class="line">git stash pop  # 将最近一次的贮藏应用到当前分支并删除该贮藏</span><br></pre></td></tr></table></figure>
<p>更详细的说明可以参考：<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86">https://git-scm.com/book/zh/v2/Git-工具-贮藏与清理</a></p>
<h3 id="暂存区-本地仓库"><a class="header-anchor" href="#暂存区-本地仓库"></a>暂存区&lt;-&gt;本地仓库</h3>
<p><strong>git commit</strong></p>
<p>一般使用<code>git comit -m &quot;your comment&quot;</code>将代码提交到本地仓库，提交后工作区清空，再次修改则需要重新<code>git add</code>，如果不加<code>-m</code>参数，那么会启动文本编辑器以输入本次提交的说明。</p>
<p>每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，加上<code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p>
<h3 id="本地仓库-远程仓库"><a class="header-anchor" href="#本地仓库-远程仓库"></a>本地仓库&lt;-&gt;远程仓库</h3>
<h4 id="git-push"><a class="header-anchor" href="#git-push"></a>git push</h4>
<p>将本地的分支版本上传到远程并合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<h4 id="git-fetch"><a class="header-anchor" href="#git-fetch"></a>git fetch</h4>
<p>从远程仓库下载最新的commit，并且同时保留本地分支head和远程分支remotes，需要另外使用<code>git merge</code>合并分支</p>
<h4 id="git-pull"><a class="header-anchor" href="#git-pull"></a>git pull</h4>
<p>下载远程分支中最新的commit并合并（不建议使用，可能出现未解决代码冲突的情况）</p>
<h3 id="操作撤销"><a class="header-anchor" href="#操作撤销"></a>操作撤销</h3>
<p>在进行文件修改等操作后，使用<code>git status</code>查看状态，可以看到git给出的撤销提示</p>
<p><img src="/2021/07/26/%E5%A4%87%E5%BF%98/git%E7%AC%94%E8%AE%B0/image-20210708151055459.png" class="lazy" data-srcset="/2021/07/26/%E5%A4%87%E5%BF%98/git%E7%AC%94%E8%AE%B0/image-20210708151055459.png" srcset="/images/loadingImage.gif" alt="image-20210708151055459"></p>
<p>更多参考：<a href="https://blog.csdn.net/Sweet_19BaBa/article/details/111950384">git checkout，git restore 和 git reset</a></p>
<h4 id="reset版本回退"><a class="header-anchor" href="#reset版本回退"></a>reset版本回退</h4>
<p>首先<code>git log</code>查看历史提交的版本信息，得到各个commit的id，即其哈希值</p>
<p>然后使用<code>git reset --hard &lt;commitId&gt;</code>切换到各个版本提交时的状态（清空暂存区），如果版本已提交到远程仓库，则需要在本地仓库回退后使用<code>git push -f</code>将操作强制同步到远程仓库。</p>
<p>但实际上回退之前的版本还是存在的，使用<code>git reflog</code>可以查看历史版本记录，找到已提交过的任何一个版本的commitId，通过commitId仍可以切回最新的未回退的版本。</p>
<h4 id="revert版本回退"><a class="header-anchor" href="#revert版本回退"></a>revert版本回退</h4>
<p>使用<code>git reset</code>回退公共远程分支的版本后，其他人都需要用远程master分支覆盖本地master分支，显然，这不是优雅的回退方法，而<code>revert</code>命令则可以避免这个问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git revert HEAD                     //撤销最近一次提交</span><br><span class="line">git revert HEAD~1                   //撤销最近2次提交</span><br><span class="line">git revert 0ffaacc                  //撤销0ffaacc这次提交</span><br></pre></td></tr></table></figure>
<p>git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的。所以，当你用revert回退完，所有人pull之后，代码也自动回退了。</p>
<h3 id="分支管理"><a class="header-anchor" href="#分支管理"></a>分支管理</h3>
<h4 id="分支新建、切换、删除"><a class="header-anchor" href="#分支新建、切换、删除"></a>分支新建、切换、删除</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch                  #列出已有分支</span><br><span class="line">git branch &lt;branchname&gt;     #创建新分支</span><br><span class="line">git checkout &lt;branchname&gt;   #切换到分支</span><br><span class="line">git branch -d &lt;branchname&gt;  #删除分支</span><br></pre></td></tr></table></figure>
<p>在一个分支进行文件修改、新建、删除等操作在commit后不会影响其他分支。</p>
<h4 id="分支合并"><a class="header-anchor" href="#分支合并"></a>分支合并</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge &lt;branchname&gt;    #把 &lt;branchname&gt; 分支合并到当前分支</span><br></pre></td></tr></table></figure>
<p>在将<code>branch2</code>合并到<code>branch1</code>的过程中，branch2中新建文件、删除原有文件、修改原有文件等操作将同步到<code>branch1</code>，当两个分支都做出修改时，可能会出现代码冲突，这时候需要我们手动修改解决冲突后再次提交才能合并成功。</p>
<p>如果我们的主分支 <code>master</code> ，在 checkout 一个新的分支（<code>bugfix</code>）后，产生了多次提交，这时候我们将<code>bugfix</code>分支合并到<code>master</code>，<code>bugfix</code>分支上新产生的所有提交记录都会同步到<code>master</code>，导致主线版本的提交记录杂乱。如果我们想要在合并分支时只产生一条提交记录，则需要使用<code>--squash</code>参数，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge --squash bugfix</span><br></pre></td></tr></table></figure>
<h2 id="常见问题"><a class="header-anchor" href="#常见问题"></a>常见问题</h2>
<ol>
<li>
<p>新建GitHub仓库，第一次push时验证账号密码失败</p>
<p>一开始提示输入GitHub的用户名口令，正确输入后还是验证失败。这时候会出现新的登录窗口，提示通过OpenSSH登录到GitHub，这时候，输入GitHub用户名和access token（settings-developer settings-Personal access tokens）即可登录成功</p>
</li>
<li>
<p>配置免密登录</p>
<p><a href="https://www.cnblogs.com/qishuaiRisen/p/16650513.html">https://www.cnblogs.com/qishuaiRisen/p/16650513.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式笔记</title>
    <url>/2020/04/18/%E5%A4%87%E5%BF%98/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2>
<blockquote>
<p>正则表达式是描述一组字符串特征的模式，用来匹配特定的字符串。 ——Ken Thompson</p>
</blockquote>
<p>一个正则表达式是一串特殊的字符串，它可以用于匹配一组字符串。比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d</span><br></pre></td></tr></table></figure>
<p>就是一个简单的正则表达式，它可以用来匹配0~9范围内的任意<strong>一个数字</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(\(\d&#123;3&#125;\)|^\d&#123;3&#125;[.-]?)?\d&#123;3&#125;[.-]?\d&#123;4&#125;$</span><br></pre></td></tr></table></figure>
<p>而上面这个式子也是一个正则表达式，只不过复杂了一些，它可以匹配10位的北美电话号码。无论区号是否加括号，数字间是否有句点或连字符，它都可以匹配。</p>
<p><strong>学习时用到的工具</strong>：</p>
<blockquote>
<p><a href="https://regex101.com/">Regexpal网站</a>：可以在线测试正则表达式</p>
</blockquote>
<h2 id="基础"><a class="header-anchor" href="#基础"></a>基础</h2>
<h3 id="字符的匹配"><a class="header-anchor" href="#字符的匹配"></a>字符的匹配</h3>
<h4 id="字面值匹配"><a class="header-anchor" href="#字面值匹配"></a>字面值匹配</h4>
<p>最简单的一种，比如一个数字字符串<code>666</code>，可以在目标文本中匹配所有的<code>666</code></p>
<p><img src="/2020/04/18/%E5%A4%87%E5%BF%98/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/fN1TQqSlujEPBCy.png" class="lazy" data-srcset="/2020/04/18/%E5%A4%87%E5%BF%98/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/fN1TQqSlujEPBCy.png" srcset="/images/loadingImage.gif" alt></p>
<h4 id="字符组匹配"><a class="header-anchor" href="#字符组匹配"></a>字符组匹配</h4>
<p>正则表达式将方括号<code>[]</code>视为特殊的元字符，因此方括号本身不参与匹配，而对括号内容进行匹配。字符组包括以下几种情况：</p>
<p><code>[aBc]</code>：匹配<code>a</code>,<code>B</code>,<code>c</code>三个字符中的其中一个</p>
<p><code>[0-9]</code>：匹配0到9范围内的任意数字。要匹配任意3位数字可以用 <code>[0-9][0-9][0-9]</code></p>
<p><code>[a-z]</code>：匹配所有小写字母</p>
<p><code>[A-Z]</code>：匹配所有大写字母</p>
<p><code>[a-zA-Z]</code>：匹配所有大小写字母</p>
<p><code>[^ARP]</code>：匹配除了<code>A</code>,<code>R</code>,<code>P</code>以外的所有字符</p>
<p><code>[^a-z]</code>：匹配所有除了小写字母以外的字符</p>
<h4 id="字符组简写式（元字符）"><a class="header-anchor" href="#字符组简写式（元字符）"></a>字符组简写式（元字符）</h4>
<p>例如：<code>[0-9]</code>可以简写为<code>\d</code>，它们都能匹配0到9之间的任意一个数字。</p>
<p>空白字符：</p>
<p><code>\f</code>：换页符</p>
<p><code>\n</code>：换行符</p>
<p><code>\r</code>：回车符</p>
<p><code>\t</code>：制表符（Tab的缩进）</p>
<p><code>\v</code>：垂直制表符</p>
<p><code>\s</code>：任意一个空白字符，等价于 [\f\n\r\t\v]</p>
<p><code>\S</code>：对<code>\s</code>取非，即任意非空字符</p>
<p>数字元字符：</p>
<p><code>\d</code>：匹配任意阿拉伯数字</p>
<p><code>\D</code>：匹配任意非数字字符（如连字符<code>-</code>)</p>
<p>字母数字元字符：</p>
<p><code>\w</code>：大小写字母，下划线和数字，等价于[a-zA-Z0-9]</p>
<p><code>\W</code>：对<code>\w</code>取非</p>
<h4 id="任意字符的匹配"><a class="header-anchor" href="#任意字符的匹配"></a>任意字符的匹配</h4>
<p><code>.</code>：点号（英文句号）可以匹配任意字符（但一般不匹配换行符）。</p>
<p><code>.</code>是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上<code> \</code> 。</p>
<h3 id="捕获分组和后向引用"><a class="header-anchor" href="#捕获分组和后向引用"></a>捕获分组和后向引用</h3>
<p>将<code>\d</code>放到<code>()</code>中，则<code>\d</code>匹配到一个数字的同时该数字被捕获。捕获之后则可以被后向引用。</p>
<p><code>\1</code>后向引用被捕获的字符。</p>
<p>例如：正则表达式 <code>(\d)\d\1</code>  可以匹配 <code>101</code> 或者 <code>212</code> , <code>383</code> 等等,但无法匹配 <code>102</code> 。因为<code>\1</code>引用的是那个被捕获的字符，所以这个正则表达式匹配到的一定是某三个相连数字，其中第一个数字和第三个数字一定是相同的。</p>
<h3 id="量词"><a class="header-anchor" href="#量词"></a>量词</h3>
<p><code>\d&#123;3&#125;</code>匹配三个相连数字，这里<code>&#123;3&#125;</code>就是一个量词，花括号中可以有多个数字（用逗号<code>,</code>隔开）比如<code>&#123;3,4&#125;</code>表示3个或者4个；</p>
<p><code>\d-?</code>匹配一个数字，如果该数字之后跟着一个连字符那么连字符也会被匹配到。这里的<code>?</code>也是一个量词，表示0个或1个；</p>
<p>同理，其他常用的量词还有</p>
<p><code>+</code>：表示1个或者多个</p>
<p><code>*</code>：表示0个或者多个</p>
<h3 id="括选文字符"><a class="header-anchor" href="#括选文字符"></a>括选文字符</h3>
<p>现在可以看看下面这个比较健壮的表达式了，就是简介中的那个，它匹配10位的北美电话号码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(\(\d&#123;3&#125;\)|^\d&#123;3&#125;[.-]?)?\d&#123;3&#125;[.-]?\d&#123;4&#125;$</span><br></pre></td></tr></table></figure>
<p><code>^</code>匹配行起始位置，即<code>^</code>后面跟着的内容<code>(\(\d&#123;3&#125;\)|^\d&#123;3&#125;[.-]?)</code>必须出现在行首；</p>
<p><code>\(</code>和<code>\)</code>就是将左右括号转义，让它表示其字面意思，而不是捕获分组的开始结束标志；</p>
<p><code>|</code>表示或运算，即匹配<code>|</code>两边的内容之一；</p>
<p><code>[.-]</code>匹配一个可选的点号（这里点号不再匹配任意字符）或连字符；</p>
<p><code>$</code>匹配行的结束标志</p>
<p>这个表达式最终匹配十位的北美电话号码，而且括号、连字符或者点号都是可选的。你可以试试不同格式的电话号码，看看它能否匹配。以上正则表达式中的捕获分组并不是必需的。分组是必要的，但是捕获不需要。更好的方法是使用非捕获分组。</p>
<h3 id="模式匹配"><a class="header-anchor" href="#模式匹配"></a>模式匹配</h3>
<p>留坑待填</p>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统加固</title>
    <url>/2021/03/07/%E6%94%BB%E9%98%B2/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/</url>
    <content><![CDATA[<h2 id="账号安全"><a class="header-anchor" href="#账号安全"></a>账号安全</h2>
<p><strong>账号相关文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/passwd    -- 记录了系统中各用户的一些基本属性，root可写，所有用户可读</span><br><span class="line">/etc/shadow    -- 记录了所有用户的密码</span><br><span class="line">/etc/group     -- 记录了用户组属性</span><br><span class="line"></span><br><span class="line">1、检查是否存在除root之外UID为0的用户：</span><br><span class="line">awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;($3==0)&#123;print $1&#125;&#x27;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">2、查询可以远程登录的帐号信息</span><br><span class="line">awk <span class="string">&#x27;/\$1|\$6/&#123;print $1&#125;&#x27;</span> /etc/shadow</span><br><span class="line"></span><br><span class="line">3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</span><br><span class="line">more /etc/sudoers | grep -v <span class="string">&quot;^#\|^$&quot;</span> | grep <span class="string">&quot;ALL=(ALL)&quot;</span></span><br><span class="line"></span><br><span class="line">4、禁用或删除多余及可疑的帐号</span><br><span class="line">usermod -L user    <span class="comment">#禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头</span></span><br><span class="line">userdel -r user    <span class="comment">#将删除user用户，并且将/home目录下的user目录一并删除</span></span><br></pre></td></tr></table></figure>
<p><strong>修改密码策略</strong></p>
<p>vim /etc/login.defs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PASS_MAX_DAYS      90               密码最长有效期</span><br><span class="line">PASS_MIN_DAYS      10               密码修改之间最小的天数</span><br><span class="line">PASS_MIN_LEN       8                密码长度</span><br><span class="line">PASS_WARN_AGE      7                口令失效前多少天开始通知用户修改密码</span><br></pre></td></tr></table></figure>
<p><strong>设置密码强度</strong></p>
<p>vim  /etc/pam.d/common-password</p>
<p>将原本的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">password requisite  pam_cracklib.so</span><br></pre></td></tr></table></figure>
<p>修改为至少包含一个数字、一个小写字母、一个大写字母、一个特殊字符、且密码长度&gt;=8:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">password requisite  pam_cracklib.so try_first_pass retry=3 dcredit=-1 lcredit=-1 ucredit=-1 ocredit=-1 minlen=8  </span><br></pre></td></tr></table></figure>
<p><strong>限制用户登陆</strong></p>
<p>vim  /etc/hosts.deny，若禁止192.168.0.1对服务器进行ssh的登陆，添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sshd : 192.168.0.1  </span><br></pre></td></tr></table></figure>
<p><strong>限制登陆次数</strong></p>
<p>应对暴力破解，我们可以限制登陆次数为5，超过5次登陆失败就锁定**。**vim /etc/pam.d/sshd，在 #%PAM-1.0 的下面，加入下面的内容，表示当密码输入错误达到3次，就锁定用户150秒，如果root用户输入密码错误达到3次，锁定300秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth required pam_tally2.so deny=3 unlock_time=150 even_deny_root root_unlock_time300</span><br></pre></td></tr></table></figure>
<p>锁定用户的管理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pam_tally2                             查看被锁定的用户</span><br><span class="line"></span><br><span class="line">pam_tally2  --reset  -u  username      将被锁定的用户解锁</span><br></pre></td></tr></table></figure>
<h2 id="目录-文件权限"><a class="header-anchor" href="#目录-文件权限"></a>目录&amp;文件权限</h2>
<p><strong>存储用户信息的文件</strong></p>
<p>在用户登陆中非常重要的三个文件</p>
<p>/etc/passwd 必须所有用户都可读，root用户可写 –rw-r—r— 权限值为644</p>
<p>/etc/shadow 只有root可读 –r-------- 权限值为400</p>
<p>/etc/group 必须所有用户都可读，root用户可写 –rw-r—r— 权限值为644</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 644 /etc/passwd</span><br><span class="line">chmod 400 /etc/shadow</span><br><span class="line">chmod 644 /etc/group</span><br></pre></td></tr></table></figure>
<p><strong>文件缺省权限设置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/profile /etc/profile.bak</span><br><span class="line">vim   /etc/profile</span><br><span class="line"><span class="comment">#添加以下内容</span></span><br><span class="line"><span class="built_in">umask</span> 022	<span class="comment">#umask与文件创建后的默认所有权限异或结果即为初始权限</span></span><br><span class="line">			<span class="comment">#root创建的文件默认所有权限为666，666~022=644 (root可读可写，其他用户只可读)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行/etc/profile中的shell命令，直接执行umask命令设置的话重启失效</span></span><br><span class="line"><span class="built_in">source</span>  /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="应用安全设置"><a class="header-anchor" href="#应用安全设置"></a>应用安全设置</h2>
<p><strong>FTP</strong></p>
<p>禁止匿名FTP</p>
<p>vim  /etc/vsftpd/vsftpd.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anonymous_enable=NO    #如果存在anonymous_enable则修改,如果不存在则手动增加</span><br></pre></td></tr></table></figure>
<p><strong>SSH</strong></p>
<ol>
<li>在sshd_config禁止root访问和使用sshv2来让ssh更加安全</li>
</ol>
<p>vim /etc/ssh/sshd_config</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PermitRootLogin    no</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>设置SSH空闲超时退出时间,可降低未授权用户访问其他用户ssh会话的风险</li>
</ol>
<p>编辑/etc/ssh/sshd_config，将ClientAliveInterval 设置为300到900，即5-15分钟，将ClientAliveCountMax设置为0-3之间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClientAliveInterval 600</span><br><span class="line">ClientAliveCountMax 2</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设置较低的Max AuthTrimes参数将降低SSH服务器被暴力攻击成功的风险</li>
</ol>
<p>在/etc/ssh/sshd_config中取消MaxAuthTries注释符号#，设置最大密码尝试失败次数3-6，建议为4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MaxAuthTries 4</span><br></pre></td></tr></table></figure>
<p><strong>TELNET</strong></p>
<p>Telnet使用明文传输数据，存在安全隐患，应该避免使用</p>
<p>执行如下语句，查看telnet服务是否在运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -na | grep <span class="string">&quot;:23&quot;</span></span><br></pre></td></tr></table></figure>
<p>若正在运行则关闭Telnet服务，在/etc/xinetd.d/telnet中进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disable=yes</span><br></pre></td></tr></table></figure>
<h2 id="网络设置"><a class="header-anchor" href="#网络设置"></a>网络设置</h2>
<p><strong>IPTABLES</strong></p>
<p>根据需求合理配置防火墙</p>
<p>比如将<code>INPUT</code>链默认规则设为<code>DROP</code>，再添加规则将需要开放的端口设置为<code>ACCEPT</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将INPUT链默认规则设置为DROP</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line"></span><br><span class="line"><span class="comment">#按需添加规则使得开放端口能够接收数据包</span></span><br><span class="line"><span class="comment">#开放SSH</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="comment">#开放80端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><strong>TCP SYN保护机制</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span>“1”&gt;/proc/sys/net/ipv4/tcp_syncookies //默认为1，一般不用设置</span><br></pre></td></tr></table></figure>
<p>表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击</p>
]]></content>
      <categories>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>系统加固</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好应急响应</title>
    <url>/2021/03/08/%E6%94%BB%E9%98%B2/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h2 id="整体思路"><a class="header-anchor" href="#整体思路"></a>整体思路</h2>
<p>1）准备</p>
<p>准备检测工具、确定相关人员。</p>
<p>2）检测与分析</p>
<p>入侵事件研判，检索分析态势感知等安全设备产生入侵告警和相关日志，确定攻击者及威胁影响范围。</p>
<p>3）抑制缓解</p>
<p>封堵攻击源、控制威胁影响范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境。</p>
<p>4）攻击溯源</p>
<p>综合分析安全设备告警、日志，主机系统日志、开放服务日志，确定攻击者入侵路径，及时修补存在的漏洞。</p>
<p>5）业务恢复</p>
<h2 id="入侵检查"><a class="header-anchor" href="#入侵检查"></a>入侵检查</h2>
<h3 id="Linux"><a class="header-anchor" href="#Linux"></a>Linux</h3>
<h4 id="常用命令"><a class="header-anchor" href="#常用命令"></a>常用命令</h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>last</td>
<td>显示的是目前与过去登入系统的用户相关信息</td>
</tr>
<tr>
<td>lastlog</td>
<td>显示所有用户的登录情况</td>
</tr>
<tr>
<td>lastb</td>
<td>显示用户错误的登录列表</td>
</tr>
<tr>
<td>who</td>
<td>显示的是当前登录的用户</td>
</tr>
<tr>
<td>w</td>
<td>比who显示多一些内容，比如用户当前执行的命令，cpu信息</td>
</tr>
<tr>
<td>history</td>
<td>查看历史命令记录</td>
</tr>
</tbody>
</table>
<h4 id="检查步骤"><a class="header-anchor" href="#检查步骤"></a>检查步骤</h4>
<ul>
<li>
<p>检查账号及登录情况</p>
<p>见这篇文章：<a href="https://dawnyh99.github.io/2021/03/07/%E8%93%9D%E9%98%9F%E6%8A%80%E6%9C%AF/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/">Linux系统加固</a></p>
</li>
<li>
<p>检查历史命令</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/bash_history &gt;&gt; history.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>检查网络连接/开放端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -antlp | more</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看 PID 所对应的进程文件路径</span></span><br><span class="line">file /proc/<span class="variable">$PID</span>/exe</span><br></pre></td></tr></table></figure>
<ul>
<li>检查异常进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep pid</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/08/%E6%94%BB%E9%98%B2/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20210313142418258.png" class="lazy" data-srcset="/2021/03/08/%E6%94%BB%E9%98%B2/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20210313142418258.png" srcset="/images/loadingImage.gif" alt="image-20210313142418258"></p>
<ul>
<li>检查开机启动项</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /etc/init.d/</span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> -l /etc/rc3.d/</span><br><span class="line"><span class="built_in">ls</span> -l /etc/rc5.d/</span><br></pre></td></tr></table></figure>
<ul>
<li>检查定时任务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /var/spool/cron/* </span><br><span class="line"><span class="built_in">cat</span> /etc/crontab</span><br><span class="line">/etc/cron.d/*</span><br><span class="line">/etc/cron.daily/* </span><br><span class="line">/etc/cron.hourly/* </span><br><span class="line">/etc/cron.monthly/*</span><br><span class="line">/etc/cron.weekly/</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看目录下所有文件</span></span><br><span class="line">more /etc/cron.d/*</span><br><span class="line"></span><br><span class="line">/etc/anacrontab</span><br><span class="line">/var/spool/anacron/*</span><br></pre></td></tr></table></figure>
<ul>
<li>检查服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CentOS</span></span><br><span class="line">chkconfig  --list  <span class="comment">#查看服务自启动状态，可以看到所有的RPM包安装的服务</span></span><br><span class="line"><span class="comment">#Debian</span></span><br><span class="line">service --status-all</span><br><span class="line">systemctl list-units</span><br><span class="line"><span class="comment">#源码包安装的服务位置</span></span><br><span class="line">/usr/local/</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>检查异常文件</p>
<ul>
<li>查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“…”为名的文件夹具有隐藏属性</li>
<li>针对可疑文件可以使用<code>stat</code>查看创建修改时间</li>
<li>发现WebShell、远控木马的创建时间</li>
</ul>
<p>找出同一时间范围内创建的文件？</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./ -iname <span class="string">&quot;*&quot;</span> -atime 1 -<span class="built_in">type</span> f </span><br><span class="line"><span class="comment">#找出 ./ 下一天前访问过的文件</span></span><br></pre></td></tr></table></figure>
<ul>
<li>检查日志文件</li>
</ul>
<p>日志默认存放位置：/var/log/</p>
<p>查看日志配置情况：more /etc/rsyslog.conf</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">记录系统定时任务相关的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/message</td>
<td style="text-align:center">记录Linux操作系统常见的系统和服务错误信息(首要检查对象)</td>
</tr>
<tr>
<td style="text-align:center">/var/log/syslog</td>
<td style="text-align:center">只记录警告信息，常常是系统出问题的信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/btmp</td>
<td style="text-align:center">记录<strong>错误登录（登陆失败）<strong>日志；使用</strong>lastb</strong>命令查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/lastlog</strong></td>
<td style="text-align:center">记录系统中所有用户最后一次成功登录时间，使用<strong>lastlog</strong>命令查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/wtmp</strong></td>
<td style="text-align:center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件；用<strong>last</strong>命令来查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/utmp</strong></td>
<td style="text-align:center">只记录<strong>当前登录用户</strong>的信息；使用<strong>w,who,users</strong>等命令来查询</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录验证和授权方面的信息，如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码</td>
</tr>
<tr>
<td style="text-align:center">/var/log/apache2/error.log</td>
<td style="text-align:center">apache错误日志，如果安装有modsecurity那么其攻击拦截日志也存在这里</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>攻防</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title>2020信安国赛WriteUp</title>
    <url>/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/</url>
    <content><![CDATA[<h2 id="Misc"><a class="header-anchor" href="#Misc"></a>Misc</h2>
<h3 id="the-best-ctf-game"><a class="header-anchor" href="#the-best-ctf-game"></a>the_best_ctf_game</h3>
<p>解压得到二进制文件:flag</p>
<p>使用winhex打开</p>
<p>观察到</p>
<p><img src="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820142658465.png" class="lazy" data-srcset="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820142658465.png" srcset="/images/loadingImage.gif" alt="image-20200820142658465"></p>
<p>即flag的值</p>
<h3 id="电脑被黑"><a class="header-anchor" href="#电脑被黑"></a>电脑被黑</h3>
<p>解压缩包得到disk_dump文件</p>
<p>使用file 命令查看信息</p>
<p><img src="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820201008231.png" class="lazy" data-srcset="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820201008231.png" srcset="/images/loadingImage.gif" alt="image-20200820201008231"></p>
<p>可以看到是ext3的文件系统</p>
<p>挂载到 test文件夹下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount ./disk_dump ./test/</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820201521587.png" class="lazy" data-srcset="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820201521587.png" srcset="/images/loadingImage.gif" alt="image-20200820201521587"></p>
<p>查看???.png，提示flag已被删除</p>
<p>使用extundelete恢复被删除的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extundelete ./disk_dump --restore-all</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820201902816.png" class="lazy" data-srcset="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820201902816.png" srcset="/images/loadingImage.gif" alt="image-20200820201902816"></p>
<p>得到flag.txt，但打开后是乱码</p>
<p>返回test/misc01文件夹下，看到可执行文件demo</p>
<p>使用strings命令查看</p>
<p><img src="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820202222131.png" class="lazy" data-srcset="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200820202222131.png" srcset="/images/loadingImage.gif" alt="image-20200820202222131"></p>
<p>猜测demo对flag.txt进行了处理</p>
<p>使用ida反编译查看其伪源码</p>
<p><img src="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/20200820202837.png" class="lazy" data-srcset="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/20200820202837.png" srcset="/images/loadingImage.gif" alt="image-20200820202837"></p>
<p>编写代码对flag文件进行解码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fileOld = fopen(<span class="string">&quot;D:\\flag.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE *fileNew = fopen(<span class="string">&quot;D:\\flagNew.txt&quot;</span>,<span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">    <span class="type">char</span> v1,v4,v5;</span><br><span class="line">    v4 = <span class="number">34</span>;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = fgetc(fileOld);</span><br><span class="line">        <span class="keyword">if</span>( v1 == <span class="number">-1</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        fputc(((v1^v4)-v5),fileNew);</span><br><span class="line">        v4 += <span class="number">34</span>;</span><br><span class="line">        v5 = (v5 + <span class="number">2</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fileNew);</span><br><span class="line">    fclose(fileOld);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解码后得到flag</p>
<h2 id="Crypto"><a class="header-anchor" href="#Crypto"></a>Crypto</h2>
<p>只做出来一道题</p>
<h3 id="baby"><a class="header-anchor" href="#baby"></a>baby</h3>
<p>一道RSA的密码学题目</p>
<p>给了我们密文c和因数n，e很小。所以可以通过爆破的方式跑出明文</p>
<p>解密脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy</span><br><span class="line">n = 691316677109436623113422493782665795857921917893759942123087462879884062720557906429183155859597756890896192044003240821906332575292476160072039505771794531255542244123516929671277306361467074545720823735806308003091983427678300287709469582282466572230066580195227278214776280213722215953097747453437289734469454712426107967188109548966907237877840316009828476200388327329144783877033491238709954473809991152727333616022406517443130542713167206421787038596312975153165848625721911080561242646092299016802662913017071685740548699163836007474224715426587609549372289181977830092677128368806113131459831182390520942892670696447128631485606579943885812260640805756035377584155135770155915782120025116486061540105139339655722904721294629149025033066823599823964444620779259106176913478839370100891213072100063101232635183636552360952762838656307300621195248059253614745118852163569388418086291748805100175008658387803878200034840215506516715640621165661642177371863874586069524022258642915100615596032443145034847031564356671559179212705466145609698475546210994748949121359853094247990533075004393534565421776468785821261291309463205314057882016266066365636018084499158806717036972590848458891019171583268920180691221168453612029698510271</span><br><span class="line">c = 3442467842482561323703237574537907554035337622762971103210557480050349359873041624336261782731509068910003360547049942482415036862904844600484976674423604861710166033558576921438068555951948966099658902606725292551952345193132973996288566246138708754810511646811362017769063041425115712305629748341207792305694590742066971202523405301561233341991037374101265623265332070787449332991792097090044761973705909217137119649091313457206589803479797894924402017273543719924849592070328396276760381501612934039653</span><br><span class="line">i = 0</span><br><span class="line">while 1:</span><br><span class="line">    if(gmpy.root(c+i*n, 3)[1]==1):</span><br><span class="line">        print gmpy.root(c+i*n, 3)</span><br><span class="line">        break</span><br><span class="line">    i = i+1</span><br></pre></td></tr></table></figure>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m=1509929362729692740720713536968392715648402189242304424408501797538190273763219595501810359943405524344790331677540693316488309231687357778980543085568230705511696327037</span><br></pre></td></tr></table></figure>
<p>再解码得到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">n=1509929362729692740720713536968392715648402189242304424408501797538190273763219595501810359943405524344790331677540693316488309231687357778980543085568230705511696327037</span><br><span class="line">print(libnum.n2s(n))</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200920135022901.png" class="lazy" data-srcset="/2020/08/22/%E6%9D%82%E8%AE%B0/2020%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9BWriteUp/image-20200920135022901.png" srcset="/images/loadingImage.gif" alt="image-20200920135022901"></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次公网IPv6配置</title>
    <url>/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<p>前段时间突发奇想，想用内网穿透的方式把家里旧电脑上开启的一些服务给暴露在公网上，这样就可以在公司远程访问了。后面查了查资料，发现相比于内网穿透，直接用公网ip去访问更加经济实惠，并且访问速度更快。于是就开始折腾起了公网ip的配置，最后达到的效果如下：</p>
<ol>
<li>开放任意的端口和服务</li>
<li>通过绑定的域名访问主机</li>
<li>动态修改域名解析配置</li>
</ol>
<p>需要注意的是，ipv6通信需要过程中的所有网络设备都支持且启用了ipv6网络，目前常见的光猫、路由器都支持ipv6网络，但大多默认没有开启，所以这俩就是我们主要需要配置的地方。这篇文章把折腾的过程记录一下，供其他感兴趣的朋友参考，如有错误也请大家及时指正。</p>
<h2 id="获取公网ip"><a class="header-anchor" href="#获取公网ip"></a>获取公网ip</h2>
<p>因为公网ipv4资源紧张，现在三大运营商基本是不会给家庭宽带分配独立的公网ipv4地址了，但所幸除了ipv4，我们还有ipv6，毕竟128位的地址空间，完全不用担心不够用。</p>
<p>ipv6的支持目前已经很普及了，但可能是为了避免不必要的麻烦，光猫的默认设置里面一般是没有开启ipv6选项的。所以我们需要先连上宽带（有线或者无线网络都行），再使用超级管理员账号登录光猫的配置页面去打开这个功能。</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230228215725750.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230228215725750.png" srcset="/images/loadingImage.gif" alt="image-20230228215725750"></p>
<blockquote>
<p>默认配置地址为 <a href="http://192.168.1.1">http://192.168.1.1</a></p>
<p>默认超级管理员账号密码：</p>
<p>移动：CMCCAdmin/aDm8H%MdA</p>
<p>电信：telecomadmin/nE7jA%5m</p>
<p>联通：CUAdmin/CUAdmin</p>
</blockquote>
<p>以移动光猫为例，登录后进入网络-宽带设置页面，选择<code>x_INTERNET_xxx</code>连接进行因特网配置</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230228220842592.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230228220842592.png" srcset="/images/loadingImage.gif" alt="image-20230228220842592"></p>
<p>网上查找到的资料大多是使用路由器进行拨号上网，而光猫使用桥接模式，这样配置起来会轻松一些。但由于我这里宽带是房东办的，我不知道密码，所以只能保持光猫拨号，路由器再从光猫这里动态地获取ip地址。所以在这里我只需要打开ipv6地址的自动获取即可，如下图所示：</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230228233437568.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230228233437568.png" srcset="/images/loadingImage.gif" alt="image-20230228233437568"></p>
<p>地址和前缀的获取方式这里可能需要自己尝试下，管不管用取决于运营商开启的分配策略。NPTv6就是ipv6版的NAT协议，如果配置好获取地址和前缀的方式后，电脑直接连接光猫能够获取公网ipv6地址，那么就不需要打开了。</p>
<p>完成宽带设置后，还需要确认下LAN侧地址配置，如下图所示：</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230228235426926.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230228235426926.png" srcset="/images/loadingImage.gif" alt="image-20230228235426926"></p>
<p>保存应用后，将电脑通过网线或者WIFI直接连上光猫，确认是否获取到公网ipv6地址。移动的ipv6是2409开头，电信和联通则是240e和2408，如果没有就需要尝试其他的获取地址方式了。</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301001400712.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301001400712.png" srcset="/images/loadingImage.gif" alt="image-20230301001400712"></p>
<p>电脑直连能够获取公网ipv6地址之后，就可以开个服务看看外网能否访问了。我这里直接用python自带的http模块去监听本机8888端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m http.server 8888</span><br></pre></td></tr></table></figure>
<p>再使用在线测试工具 <a href="https://ipw.cn/ipv6webcheck/">https://ipw.cn/ipv6webcheck/</a> 判断能否访问（测试时暂时关闭本机和光猫的防火墙）</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301003503371.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301003503371.png" srcset="/images/loadingImage.gif" alt="image-20230301003503371"></p>
<p>访问失败，但不知道是哪里出了问题，于是摸索了很久，最后试着打开了光猫的ipv6虚拟服务器功能，填入想要开放公网访问的端口，发现连接成功，估计是光猫的默认策略里禁用了传入的连接，需要在这里单独配置后才能被互联网访问。</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301003924298.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301003924298.png" srcset="/images/loadingImage.gif" alt="image-20230301003924298"></p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301004108524.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301004108524.png" srcset="/images/loadingImage.gif" alt="image-20230301004108524"></p>
<p>这时候我们就可以继续设置路由器了，这里就比较简单了。进入路由器的管理页面，不同品牌和型号的路由器配置方法不同，具体方法可以到生产厂商官网查找对应的配置说明。我这里用的是华硕的RT-AC68U，在高级设置-IPv6中配置ipv6地址获取方式，根据官网的文档，选择穿透模式（Passthrough）即可。</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301100022508.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301100022508.png" srcset="/images/loadingImage.gif" alt="image-20230301100022508"></p>
<p>这个模式会把路由器的WAN口、LAN口和WiFi桥接起来，一级路由（即光猫）下发的ipv6地址通过网桥直接分配给二级路由下的终端，可以理解为在ipv6网络中，我的路由器是以交换机模式工作的。</p>
<p>配置完后，同样暂时关闭路由器的ipv6防火墙，电脑连接路由器的WiFi，看是否能够像直连光猫一样获取公网ipv6，获取到了基本就没问题了。</p>
<h2 id="防火墙配置"><a class="header-anchor" href="#防火墙配置"></a>防火墙配置</h2>
<p>毕竟是直接暴露在公网上，访问控制还是得做的。主要是光猫、路由器、电脑本机上的防火墙策略需要开启。</p>
<p>光猫的配置页面里面，在安全-防火墙中配置防火墙策略，但这里只能选择低中高等级，并不知道具体控制策略，主要起一个心理作用。</p>
<p>路由器的配置，在高级设置-防火墙里面可以配置，开启ipv6防火墙后默认拒绝所有传入连接，可指定ip和端口开放，但考虑到主机ip是从光猫动态获取的，可能会变化，所以这里就没有启用。</p>
<p>终端防火墙的配置，Windows可以直接在高级防火墙设置里添加允许的传入连接，未匹配到允许规则时windows防火墙默认会拒绝连接。</p>
<h2 id="域名配置"><a class="header-anchor" href="#域名配置"></a>域名配置</h2>
<p>能通过IP访问后，为了让访问过程更方便，我决定申请个域名，通过域名来访问主机，再通过定时执行检查脚本来实现ddns的功能。</p>
<p>查了一些资料后，我在<a href="https://www.namesilo.com/">namesilo</a>花 1.88 美元租了个一年的域名，选他主要是因为便宜、免备案还免费提供whois信息隐藏服务，再把域名解析服务器设置为阿里云，这样管理起来方便一点。</p>
<p><img src="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301125904797.png" class="lazy" data-srcset="/2023/02/28/%E6%9D%82%E8%AE%B0/%E5%85%AC%E7%BD%91ipv6%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/image-20230301125904797.png" srcset="/images/loadingImage.gif" alt="image-20230301125904797"></p>
<p>这里配置完后，到阿里云的控制台，找到<a href="https://dns.console.aliyun.com/">云解析DNS</a>，页面上简单配置即可，这样下来我们就可以愉快地通过域名访问家里的主机了。</p>
<p>最后是定时检查ip是否改变，这里我参照阿里云的openApi简单写个python脚本，发现ip变化就通过阿里云的Api去修改解析记录，再通过计划任务运行即可。</p>
<h2 id="注意事项"><a class="header-anchor" href="#注意事项"></a>注意事项</h2>
<p>尽管我们通过防火墙对传入连接做了限制，但尽量还是只开放一些静态内容，比如个人博客。如果一定要开放一些FTP、SSH之类的服务，记得选择没有公开漏洞的组件版本，并使用强口令认证。</p>
<h2 id="TODO"><a class="header-anchor" href="#TODO"></a>TODO</h2>
<ol>
<li>
<p>使用虚拟机对外开放服务</p>
</li>
<li>
<p>证书配置</p>
</li>
</ol>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP&amp;IP</title>
    <url>/2021/03/14/%E5%A4%87%E5%BF%98/TCP&amp;IP/</url>
    <content><![CDATA[<h2 id="TCP"><a class="header-anchor" href="#TCP"></a>TCP</h2>
<h3 id="三次握手和四次挥手"><a class="header-anchor" href="#三次握手和四次挥手"></a>三次握手和四次挥手</h3>
<p>TCP是可靠的，面向连接的传输层协议，端到端之间要进行TCP通信首先就要建立起TCP连接，当通信结束时断开TCP连接。这里TCP连接的建立与断开过程就分别由<code>三次握手</code>和<code>四次挥手</code>来完成。</p>
<ul>
<li>
<p>三次握手</p>
<p>TCP连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。具体过程如下图所示。</p>
<p><img src="/2021/03/14/%E5%A4%87%E5%BF%98/TCP&IP/image-20210316191610581.png" class="lazy" data-srcset="/2021/03/14/%E5%A4%87%E5%BF%98/TCP&IP/image-20210316191610581.png" srcset="/images/loadingImage.gif" alt="image-20210316191610581"></p>
<p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，SYN位置为1，Sequence Number为随机数<code>i</code>；然后，客户端进入SYN_SENT状态，等待服务器的确认；</p>
<p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为<code>i+1</code> ( Sequence Number+1 )；同时，自己自己还要发送SYN请求信息，SYN设置为1，Sequence Number为<code>j</code>；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RCVD状态；</p>
<p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为<code>j+1</code>，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<p>在wireshark中可以分别查看<code>ACK</code>和<code>Seq</code>的实际值和相对值，第一个包的Seq相对值为0。</p>
<p><strong><code>Seq</code>的相对值为当前端已发送的TCP总段长，<code>ACK</code>的相对值为当前端已接收的TCP总段长（单位：字节），</strong><code>SYN</code>标志位和<code>FIN</code>标志位也要占1字节（其他标志位如ACK不占）。</p>
</li>
<li>
<p>四次挥手</p>
<img src="/2021/03/14/%E5%A4%87%E5%BF%98/TCP&IP/image-20210316213743223.png" class="lazy" data-srcset="/2021/03/14/%E5%A4%87%E5%BF%98/TCP&IP/image-20210316213743223.png" srcset="/images/loadingImage.gif" style="zoom:50%;">
<p><strong>中断连接端可以是Client端，也可以是Server端。</strong></p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，“就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
</li>
</ul>
<h3 id="TCP和UDP的对比"><a class="header-anchor" href="#TCP和UDP的对比"></a>TCP和UDP的对比</h3>
<p>有连接/无连接（可靠/不可靠）</p>
<p>有拆分合并/无拆分合并</p>
<p>有拥塞控制/无拥塞控制（发送速率的调整）</p>
<p>单播/多播</p>
<h3 id="滑动窗口和流量控制"><a class="header-anchor" href="#滑动窗口和流量控制"></a>滑动窗口和流量控制</h3>
<h3 id="拥塞控制"><a class="header-anchor" href="#拥塞控制"></a>拥塞控制</h3>
<h2 id="http-https"><a class="header-anchor" href="#http-https"></a>http/https</h2>
<h3 id="http各版本区别"><a class="header-anchor" href="#http各版本区别"></a>http各版本区别</h3>
<p>http1.0 vs http1.1</p>
<p>http1.1开始，默认使用长连接（HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。）</p>
<p>http1.1增加了一些错误状态码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<h3 id="SSL-TLS"><a class="header-anchor" href="#SSL-TLS"></a>SSL/TLS</h3>
<ul>
<li>首先由客户端发送Client Hello 消息到服务器，消息中主要包含了客户端支持的<code>ciphersuites</code>， TLS 版本信息和客户端随机数。<strong>注意此时是明文传输</strong></li>
<li>服务器接收到消息后，返回自己支持的<code>ciphersuites</code>， TLS 版本，<strong>自己的数字证书</strong>和服务器端生成的随机数。<strong>注意此时是明文传输</strong></li>
<li>客户端开始验证数字证书，可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，直到一个受信的 CA。验证完证书之后生成一个新的<code>pre-master key</code>，再使用证书中的公钥来对<code>pre-master key</code>进行加密，然后发送给服务器。<strong>注意此时是非对称加密传输</strong></li>
<li>服务器接收到客户端发送过来的非对称加密的密文，使用自己的私钥进行解密，获得了<code>pre-master key</code>。<strong>注意此时是非对称加密传输</strong></li>
<li>到这里为止，服务器和客户端都有三组数字，**分别是客户端的随机数、服务器的随机数和pre-master key。**其中由于客户端的随机数和服务器的随机数都是使用明文传输，所以这两个数字是有被暴露的风险的，但是由于<code>pre-master key</code>是使用非对称加密传输，十分安全，所以将这三者结合，使用之前协商好的特定的算法就可以生成一个密钥，这个密钥称为<code>shared secert</code>。也就是之后用来对称加密的密钥。</li>
<li>客户端在计算出对称加密的密钥之后，使用该密钥进行对称加密通信，告知服务器之后都使用该密钥进行对称加密。<strong>注意此时是对称加密传输</strong></li>
<li>服务器接收到密文后，使用之前计算出的密钥来进行对称解密，解密成功之后，再使用该密钥进行对称加密通信。告知客户端密钥确认无误，可以使用该密钥进行通信。<strong>注意此时是对称加密传输</strong></li>
<li>至此，整个TLS的握手过程完整，之后就可以开始对称加密的通信了。</li>
</ul>
<h2 id="参考文章"><a class="header-anchor" href="#参考文章"></a>参考文章</h2>
<ul>
<li><a href="https://blog.csdn.net/whuslei/article/details/6667471">TCP协议中的三次握手和四次挥手(图解)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/72587882">关于 TCP/IP，必知必会的10个问题</a></li>
</ul>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2020/04/06/%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[<p>一个对网络安全初窥门径的人，偶尔会心血来潮想要写写代码。</p>
<p>邮箱：dawnyh@qq.com，欢迎交流 ~</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>在Markdown中使用emoji表情</title>
    <url>/2020/04/07/%E6%9D%82%E8%AE%B0/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/</url>
    <content><![CDATA[<h2 id="常用emoji"><a class="header-anchor" href="#常用emoji"></a>常用emoji</h2>
<p><img src="/2020/04/07/%E6%9D%82%E8%AE%B0/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/u8SbATtdLwU5VjB.png" class="lazy" data-srcset="/2020/04/07/%E6%9D%82%E8%AE%B0/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/u8SbATtdLwU5VjB.png" srcset="/images/loadingImage.gif" alt></p>
<p>理想情况下，在Markdown编辑器中输入如上图所示的语句后将显示对应的emoji表情。但实际上是否显示则取决于你的markdown解析器。</p>
<h2 id="hexo博客使用emoji"><a class="header-anchor" href="#hexo博客使用emoji"></a>hexo博客使用emoji</h2>
<p><strong>hexo</strong> 框架默认的markdown解析器是<code>hexo-renderer-marked</code>，并不支持emoji表情的解析。所以如果想要在博客文章里添加emoji表情😮，可以考虑使用<code>hexo-renderer-markdown-it</code> 解析器。</p>
<p>首先打开Node.js的命令行并移动到你的博客根目录下</p>
<p><img src="/2020/04/07/%E6%9D%82%E8%AE%B0/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/jQKAbRWvhGMDFgx.png" class="lazy" data-srcset="/2020/04/07/%E6%9D%82%E8%AE%B0/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/jQKAbRWvhGMDFgx.png" srcset="/images/loadingImage.gif" alt></p>
<p>卸载原有的<code>hexo-renderer-marked</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked -S</span><br></pre></td></tr></table></figure>
<p>再安装<code>hexo-renderer-markdown-it</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-markdown-it -S</span><br></pre></td></tr></table></figure>
<p>完成之后安装所需的插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i markdown-it-emoji -S</span><br></pre></td></tr></table></figure>
<p>最后打开根目录下的<code>_config.yml</code>文件，添加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  render:</span><br><span class="line">    html: true ## 在 markdown 文本中支持 html tag 标签</span><br><span class="line">    xhtmlOut: false ## 需要 xtml 文档，使用 &lt;br /&gt; 替代 &lt;br&gt;</span><br><span class="line">    breaks: true ## 用 &lt;br&gt; 开始新的一行</span><br><span class="line">    linkify: true ## 自动将 可能是链接的内容转换成链接</span><br><span class="line">    typographer: true ## 印刷标识转换</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-emoji ## emoji表情插件</span><br><span class="line">    - markdown-it-abbr ## 可选</span><br><span class="line">    - markdown-it-footnote ## 可选</span><br><span class="line">    - markdown-it-ins ## 可选，</span><br><span class="line">    - markdown-it-sub ## 可选，下标，如H2O</span><br><span class="line">    - markdown-it-sup ## 可选，上标，如2^10</span><br><span class="line">  anchors:</span><br><span class="line">    level: 2</span><br><span class="line">    collisionSuffix: &#x27;&#x27;</span><br><span class="line">    permalink: false,</span><br><span class="line">    permalinkClass: &#x27;header-anchor&#x27;</span><br><span class="line">    permalinkSymbol: &#x27;&#x27;</span><br><span class="line">    case: 0</span><br><span class="line">    separator: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>然后保存退出，再重新加载一下hexo即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>参考来源： <a href="https://zucchiniy.cn/archives/953e2b.html">ZucchinY的博客</a></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>网络代理设置</title>
    <url>/2021/07/08/%E5%A4%87%E5%BF%98/%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="命令行代理设置"><a class="header-anchor" href="#命令行代理设置"></a>命令行代理设置</h2>
<p>设置命令行代理（设置环境变量,命令行关闭后则失效）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># cmd</span></span></span><br><span class="line">set HTTP_PROXY=http://127.0.0.1:10809</span><br><span class="line">set HTTPS_PROXY=http://127.0.0.1:10809</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># powershell 默认使用系统代理，无需手动配置</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># bash</span></span></span><br><span class="line">export http_proxy=&quot;http://127.0.0.1:10809&quot;</span><br><span class="line">export https_proxy=&quot;http://127.0.0.1:10809&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 测试是否设置成功不要ping google，因为ping命令用的是ICMP协议。正确做法是</span></span></span><br><span class="line">curl www.google.com</span><br></pre></td></tr></table></figure>
<h2 id="git代理设置"><a class="header-anchor" href="#git代理设置"></a>git代理设置</h2>
<p>设置永久有效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:10809	</span><br><span class="line">git config --global https.proxy https://127.0.0.1:10809</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 若为socks代理，则为：</span></span></span><br><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:10808&#x27;</span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:10808&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看代理是否设置成功</span></span><br><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<h2 id="go代理设置"><a class="header-anchor" href="#go代理设置"></a>go代理设置</h2>
<p>Bash (Linux / macOS)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.io,direct</span><br></pre></td></tr></table></figure>
<p>PowerShell (Windows)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">env</span>:GOPROXY = <span class="string">&quot;https://goproxy.io,direct&quot;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的自动类型转换</title>
    <url>/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>在查询语句的条件判断子句中，如果等号左右两边的类型不同，则会自动进行类型转换。以如下数据表为例</p>
<p><img src="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084058433.png" class="lazy" data-srcset="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084058433.png" srcset="/images/loadingImage.gif" alt="image-20200722084058433"></p>
<p><img src="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082629984.png" class="lazy" data-srcset="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082629984.png" srcset="/images/loadingImage.gif" alt="image-20200722082629984"></p>
<p><code>DVWA</code>的<code>user</code>表👆</p>
<p>在进行以下查询时结果如图：</p>
<p><img src="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082807883.png" class="lazy" data-srcset="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082807883.png" srcset="/images/loadingImage.gif" alt="image-20200722082807883"></p>
<p><img src="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082829117.png" class="lazy" data-srcset="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082829117.png" srcset="/images/loadingImage.gif" alt="image-20200722082829117"></p>
<p><img src="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084904218.png" class="lazy" data-srcset="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084904218.png" srcset="/images/loadingImage.gif" alt="image-20200722084904218"></p>
<p><img src="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084727031.png" class="lazy" data-srcset="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084727031.png" srcset="/images/loadingImage.gif" alt="image-20200722084727031"></p>
<p><img src="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722083932481.png" class="lazy" data-srcset="/2020/07/22/%E6%9D%82%E8%AE%B0/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722083932481.png" srcset="/images/loadingImage.gif" alt="image-20200722083932481"></p>
<p>通过上面几个查询的例子可以看到，mysql查询语句的条件判断中，像user_id = ‘xxx’ 这种条件，user_id 是整型，而 ‘xxx’ 是字符串型，在判断时，'xxx’会被当作一个整型与 user_id进行比较。</p>
<p>而转换的规则也很有意思。</p>
<p>‘1 and 1=1’ 被当作 1</p>
<p>‘1 and 1=2’ 也被当作1</p>
<p>‘2 and 1=1’ 被当作2</p>
<p>经过更多的测试可以发现</p>
<p>这个字符串（不论是单引号或者是双引号）在被当作整型数进行处理的时候</p>
<p>如果第一个字符不是数字，那么该字符串被当成<code>0</code>来处理；</p>
<p>如果第一个字符是数字，那么这个字符串就等于从第一个字符开始的数字串</p>
<p>比如：‘4gsb’ = 4；‘108hh’ = 108</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
